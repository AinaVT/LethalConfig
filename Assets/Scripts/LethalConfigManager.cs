using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using BepInEx.Configuration;
using LethalConfig.AutoConfig;
using LethalConfig.ConfigItems;
using LethalConfig.Mods;
using LethalConfig.Utils;
using UnityEngine;

namespace LethalConfig
{
    public static class LethalConfigManager
    {
        private static readonly List<AutoConfigGenerator.ConfigFileAssemblyPair> CustomConfigFiles = new();

        private static bool _hasGeneratedMissingConfigs;
        internal static Dictionary<string, Mod> Mods { get; } = new();
        private static Dictionary<Mod, Assembly> ModToAssemblyMap { get; } = new();

        internal static void AutoGenerateMissingConfigsIfNeeded()
        {
            if (_hasGeneratedMissingConfigs) return;

            var existingModEntries = Mods.Values.ToArray();
            var existingConfigsFlat = Mods.SelectMany(kv => kv.Value.ConfigItems);
            var generatedConfigs = AutoConfigGenerator.AutoGenerateConfigs(CustomConfigFiles.ToArray());
            var missingConfigs = generatedConfigs
                .GroupBy(c => ModForAssembly(c.Assembly), c => c.ConfigItem)
                .Where(kv => kv.Key != null)
                .SelectMany(kv =>
                {
                    return kv.Select(c =>
                        {
                            c.Owner = kv.Key;
                            return c;
                        })
                        .Where(c => !kv.Key.EntriesToSkipAutoGen.Any(path => path.Matches(c)))
                        .Where(c => existingConfigsFlat.FirstOrDefault(c.IsSameConfig) == null)
                        .GroupBy(c => c.Owner);
                }).ToDictionary(kv => kv.Key, kv => kv.Select(c => c));

            var generatedModEntries = missingConfigs.Keys.Except(existingModEntries).ToArray();
            foreach (var entry in generatedModEntries)
            {
                entry.IsAutoGenerated = true;
                entry.ModInfo.Description +=
                    "\n*This mod entry was automatically generated as it does not use LethalConfig directly.";
            }

            foreach (var kv in missingConfigs)
            {
                var assembly = ModToAssemblyMap.GetValueOrDefault(kv.Key);
                if (assembly != null)
                    foreach (var config in kv.Value)
                        AddConfigItemForAssembly(config, assembly);
            }

            LogUtils.LogInfo($"Generated {generatedModEntries.Count()} mod entries.");
            LogUtils.LogInfo(
                $"Generated {generatedConfigs.Length} configs, of which {missingConfigs.SelectMany(kv => kv.Value).Count()} were missing and registered.");

            _hasGeneratedMissingConfigs = true;
        }

        /// <summary>
        ///     Adds a config item to the calling's mod entry UI.
        /// </summary>
        public static void AddConfigItem(BaseConfigItem configItem)
        {
            if (AddConfigItemForAssembly(configItem, Assembly.GetCallingAssembly()))
                LogUtils.LogInfo($"Registered config \"{configItem}\"");
        }

        private static bool AddConfigItemForAssembly(BaseConfigItem configItem, Assembly assembly)
        {
            var mod = ModForAssembly(assembly);
            if (mod == null)
            {
                LogUtils.LogWarning("Mod for assembly not found.");
                return false;
            }

            configItem.Owner = mod;
            if (mod.ConfigItems.Any(c => c.IsSameConfig(configItem)))
            {
                LogUtils.LogWarning($"Ignoring duplicated config \"{configItem}\"");
                return false;
            }

            mod.AddConfigItem(configItem);
            return true;
        }

        private static Mod ModForAssembly(Assembly assembly)
        {
            if (!assembly.TryGetModInfo(out var modInfo)) return null;
            if (Mods.TryGetValue(modInfo.Guid, out var mod)) return mod;

            var newMod = new Mod(modInfo);
            Mods.Add(modInfo.Guid, newMod);
            ModToAssemblyMap.Add(newMod, assembly);
            return newMod;
        }

        /// <summary>
        ///     Overwrite the mod icon used when displaying the calling's mod entry.
        /// </summary>
        public static void SetModIcon(Sprite sprite)
        {
            if (sprite == null) return;

            var mod = ModForAssembly(Assembly.GetCallingAssembly());
            if (mod == null) return;

            mod.ModInfo.Icon = sprite;
        }

        /// <summary>
        ///     Overwrite the mod description used when displaying the calling's mod entry.
        /// </summary>
        public static void SetModDescription(string description)
        {
            if (description == null) return;

            var mod = ModForAssembly(Assembly.GetCallingAssembly());
            if (mod == null) return;

            mod.ModInfo.Description = description;
        }

        /// <summary>
        ///     Skip Automatic Generation for a specific section
        /// </summary>
        public static void SkipAutoGenFor(string configSection)
        {
            var mod = ModForAssembly(Assembly.GetCallingAssembly());

            mod?.EntriesToSkipAutoGen.Add(new ConfigEntryPath(configSection, "*"));
        }

        /// <summary>
        ///     Skip Automatic Generation for a specific <see cref="ConfigEntry{T}" />
        /// </summary>
        public static void SkipAutoGenFor(ConfigEntryBase configEntryBase)
        {
            var mod = ModForAssembly(Assembly.GetCallingAssembly());

            mod?.EntriesToSkipAutoGen.Add(new ConfigEntryPath(configEntryBase.Definition.Section,
                configEntryBase.Definition.Key));
        }

        /// <summary>
        ///     Skip Automatic Generation for your mod entirely
        /// </summary>
        public static void SkipAutoGen()
        {
            var mod = ModForAssembly(Assembly.GetCallingAssembly());

            mod?.EntriesToSkipAutoGen.Add(new ConfigEntryPath("*", "*"));
        }

        /// <summary>
        ///     Queues a custom config file for auto generation
        /// </summary>
        /// <param name="configFile">The custom config file instance.</param>
        public static void QueueCustomConfigFileForAutoGeneration(ConfigFile configFile)
        {
            CustomConfigFiles.Add(new AutoConfigGenerator.ConfigFileAssemblyPair
            {
                ConfigFile = configFile,
                Assembly = Assembly.GetCallingAssembly()
            });
        }
    }
}