using UnityEngine;
using BepInEx.Configuration;
using LethalConfig.Mods;
using LethalConfig.ConfigItems.Options;
using System;

namespace LethalConfig.ConfigItems
{
    public abstract class BaseConfigItem
    {
        internal delegate void CurrentValueChangedHandler();

        internal ConfigEntryBase BaseConfigEntry { get; private set; }
        internal BaseOptions Options { get; }
        internal bool RequiresRestart => Options.RequiresRestart;
        internal Mod Owner { get; set; }
        internal bool IsAutoGenerated { get; set; } = false;

        private string UnderlyingSection => BaseConfigEntry?.Definition.Section ?? string.Empty;
        private string UnderlyingName => BaseConfigEntry?.Definition.Key ?? string.Empty;
        private string UnderlyingDescription => BaseConfigEntry?.Description.Description ?? string.Empty;

        internal string Section => Options.Section ?? UnderlyingSection;
        internal string Name => Options.Name ?? UnderlyingName;
        internal string Description => Options.Description ?? UnderlyingDescription;

        internal object OriginalBoxedValue => BaseConfigEntry?.BoxedValue;
        internal object BoxedDefaultValue => BaseConfigEntry?.DefaultValue;
        private object _currentBoxedValue;
        internal object CurrentBoxedValue
        {
            get => _currentBoxedValue;
            set
            {
                _currentBoxedValue = value;
                OnCurrentValueChanged?.Invoke();
            }
        }

        internal bool HasValueChanged => (!CurrentBoxedValue?.Equals(OriginalBoxedValue)) ?? false;

        internal abstract GameObject CreateGameObjectForConfig();

        internal event CurrentValueChangedHandler OnCurrentValueChanged;

        internal void ApplyChanges()
        {
            if (BaseConfigEntry == null) return;
            BaseConfigEntry.BoxedValue = CurrentBoxedValue;
        }

        internal void CancelChanges()
        {
            CurrentBoxedValue = OriginalBoxedValue;
        }

        internal void ChangeToDefault()
        {
            CurrentBoxedValue = BoxedDefaultValue;
        }

        internal BaseConfigItem(BaseOptions options) : this(null, options) { }

        internal BaseConfigItem(ConfigEntryBase configEntry, BaseOptions options)
        {
            BaseConfigEntry = configEntry;
            Options = options;
            CurrentBoxedValue = OriginalBoxedValue;
        }

        internal bool IsSameConfig(BaseConfigItem configItem)
        {
            var isSameSection = configItem.UnderlyingSection == UnderlyingSection;
            var isSameKey = configItem.UnderlyingName == UnderlyingName;
            var isSameMod = configItem.Owner.modInfo.GUID == Owner.modInfo.GUID;
            return isSameSection && isSameKey && isSameMod;
        }
    }

    public abstract class BaseValueConfigItem<T> : BaseConfigItem
    {
        internal ConfigEntry<T> ConfigEntry => (ConfigEntry<T>)BaseConfigEntry;
        internal T CurrentValue
        {
            get => (T)CurrentBoxedValue;
            set => CurrentBoxedValue = value;
        }
        internal T OriginalValue => ConfigEntry.Value;
        internal T Defaultvalue => (T)ConfigEntry.DefaultValue;

        internal BaseValueConfigItem(ConfigEntry<T> configEntry, BaseOptions options): base(configEntry, options)
        {
            CurrentValue = OriginalValue;
            if (ConfigEntry != null)
                ConfigEntry.SettingChanged += OnUnderlyingEntryChanged;
        }

        ~BaseValueConfigItem()
        {
            if (ConfigEntry != null)
                ConfigEntry.SettingChanged -= OnUnderlyingEntryChanged;
        }

        private void OnUnderlyingEntryChanged(object sender, EventArgs args)
        {
            CurrentValue = OriginalValue;
        }

        public override string ToString()
        {
            return $"{Owner.modInfo.Name}/{ConfigEntry.Definition.Section}/{ConfigEntry.Definition.Key}";
        }
    } 
}
